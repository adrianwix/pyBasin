"""SymPy-based ODE definition for the Zig solver.

Allows Python developers to write ODEs symbolically. The symbolic expressions
are printed to C source code, compiled to a shared library with the same ABI
as Zig-defined ODEs, and loaded by :class:`ZigODESolver` transparently.

Usage::

    import sympy as sp
    from zigode import SymPyODE, ZigODESolver

    theta, dtheta = sp.symbols("theta dtheta")
    alpha, T, K = sp.symbols("alpha T K")

    pendulum = SymPyODE(
        name="pendulum_sympy",
        state=[theta, dtheta],
        params=[alpha, T, K],
        rhs=[
            dtheta,
            -alpha * dtheta + T - K * sp.sin(theta),
        ],
    )

    solver = ZigODESolver()
    t, y = solver.solve(
        pendulum,
        [0.5, 0.0],
        (0.0, 10.0),
        t_eval,
        params={"alpha": 0.1, "T": 0.5, "K": 1.0},
    )
"""

from __future__ import annotations

from pathlib import Path

import sympy as sp
from sympy.printing.c import C99CodePrinter

from ._paths import USER_ODE_DIR
from .zig_solver import ODEDefinition

# ============================================================
# C source template
# ============================================================

_C_TEMPLATE = """\
/* Auto-generated by sympy_ode.py â€” do not edit manually. */
#include <math.h>
#include <stddef.h>

typedef struct {{
{param_fields}
}} Params;

void ode_func(double t, const double *y, double *dydt,
              const void *params_ptr, size_t dim)
{{
    (void)t;
    (void)dim;
    const Params *p = (const Params *)params_ptr;
{state_vars}
{param_vars}
{rhs_lines}
}}

size_t ode_dim(void)
{{
    return {dim};
}}

size_t ode_param_size(void)
{{
    return sizeof(Params);
}}
"""


class SymPyODE(ODEDefinition):
    """An ODE defined symbolically in Python via SymPy.

    Generates a C source file in ``user_odes/``. Compilation and loading
    happen automatically when passed to :meth:`ZigODESolver.solve`.

    :param name: ODE identifier used as the filename stem and cache key.
        Must not conflict with an existing ``.zig`` ODE of the same name.
    :param state: Ordered list of state-variable symbols, matching the order
        of entries in the ``y`` vector.
    :param params: Ordered list of parameter symbols, matching the layout of
        the C ``Params`` struct.
    :param rhs: Expressions for the time derivatives, same order as ``state``.
    """

    def __init__(
        self,
        name: str,
        state: list[sp.Symbol],
        params: list[sp.Symbol],
        rhs: list[sp.Expr],
    ) -> None:
        if len(rhs) != len(state):
            raise ValueError(f"rhs has {len(rhs)} entries but state has {len(state)}")
        self._name = name
        self._state = state
        self._params = params
        self._rhs = rhs

    # --------------------------------------------------------
    # ODEDefinition interface
    # --------------------------------------------------------

    @property
    def name(self) -> str:
        return self._name

    @property
    def param_names(self) -> list[str]:
        return [p.name for p in self._params]

    def source_exists(self) -> bool:
        return self._source_path().exists()

    def ensure_source(self) -> Path:
        """Write the C source file if it doesn't already exist.

        :return: Path to the source file.
        """
        return self._write_source()

    # --------------------------------------------------------
    # C code generation
    # --------------------------------------------------------

    def to_c_source(self) -> str:
        """Return the complete C source string for this ODE.

        :return: C source code as a string.
        """
        printer = C99CodePrinter()

        param_fields = "\n".join(f"    double {p.name};" for p in self._params)
        state_vars = "\n".join(f"    double {s.name} = y[{i}];" for i, s in enumerate(self._state))
        param_vars = "\n".join(f"    double {p.name} = p->{p.name};" for p in self._params)
        rhs_lines = "\n".join(
            f"    dydt[{i}] = {printer.doprint(expr)};"  # type: ignore[reportUnknownMemberType]
            for i, expr in enumerate(self._rhs)
        )

        return _C_TEMPLATE.format(
            param_fields=param_fields,
            state_vars=state_vars,
            param_vars=param_vars,
            rhs_lines=rhs_lines,
            dim=len(self._state),
        )

    # --------------------------------------------------------
    # Internal helpers
    # --------------------------------------------------------

    def _source_path(self) -> Path:
        return USER_ODE_DIR / f"{self._name}.c"

    def _write_source(self) -> Path:
        USER_ODE_DIR.mkdir(parents=True, exist_ok=True)
        path = self._source_path()
        path.write_text(self.to_c_source())
        return path
